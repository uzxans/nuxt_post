{"version":3,"sources":["../src/codeFrame.ts"],"sourcesContent":["import os from 'node:os'\n\nimport { codeFrameColumns, type SourceLocation } from '@babel/code-frame'\n\n/**\n * Create a code frame from source code and location\n * @param source source code\n * @param location babel compatible location to highlight\n */\nexport function createFrame(source: string, location: SourceLocation): string {\n  return codeFrameColumns(source, location, {\n    // worker tty did not fork parent process stdout, let's make a workaround\n    forceColor: true,\n  })\n    .split('\\n')\n    .map((line) => `  ${line}`)\n    .join(os.EOL)\n}\n\nexport function tsLikeLocToBabelLoc(\n  tsLoc: Record<\n    'start' | 'end',\n    { line: number; character: number } /** 0-based */\n  >,\n): SourceLocation {\n  return {\n    start: { line: tsLoc.start.line + 1, column: tsLoc.start.character + 1 },\n    end: { line: tsLoc.end.line + 1, column: tsLoc.end.character + 1 },\n  }\n}\n\nexport function lineColLocToBabelLoc(d: {\n  line: number\n  column: number\n  endLine?: number\n  endColumn?: number\n}): SourceLocation {\n  return {\n    start: { line: d.line, column: d.column },\n    end: { line: d.endLine || 0, column: d.endColumn },\n  }\n}\n\n/**\n * Convert a [startOffset, length] range into a Babel-compatible SourceLocation.\n * - Lines/columns are 1-based.\n * - Offsets and length are clamped to source bounds.\n * - Single-pass up to the end offset, minimal allocations.\n */\nexport function offsetRangeToBabelLocation(\n  source: string,\n  offset: number,\n  length: number,\n): SourceLocation {\n  const defaultPos = { line: 1, column: 1 }\n\n  if (!source || source.length === 0) {\n    return { start: { ...defaultPos }, end: { ...defaultPos } }\n  }\n\n  const startIndex = offset\n  const endIndex = offset + length\n\n  let line = 1\n  let column = 1\n\n  let start: { line: number; column: number } | null = null\n\n  for (let i = 0; i < endIndex; i++) {\n    if (i === startIndex) {\n      start = { line, column }\n    }\n    // '\\n' charCode is 10\n    if (source[i] === '\\n') {\n      line++\n      column = 1\n    } else {\n      column++\n    }\n  }\n\n  start ??= { line, column }\n  const end = { line, column }\n\n  return { start, end }\n}\n"],"mappings":"AAAA,OAAO,QAAQ;AAEf,SAAS,wBAA6C;AAO/C,SAAS,YAAY,QAAgB,UAAkC;AAC5E,SAAO,iBAAiB,QAAQ,UAAU;AAAA;AAAA,IAExC,YAAY;AAAA,EACd,CAAC,EACE,MAAM,IAAI,EACV,IAAI,CAAC,SAAS,KAAK,IAAI,EAAE,EACzB,KAAK,GAAG,GAAG;AAChB;AAEO,SAAS,oBACd,OAIgB;AAChB,SAAO;AAAA,IACL,OAAO,EAAE,MAAM,MAAM,MAAM,OAAO,GAAG,QAAQ,MAAM,MAAM,YAAY,EAAE;AAAA,IACvE,KAAK,EAAE,MAAM,MAAM,IAAI,OAAO,GAAG,QAAQ,MAAM,IAAI,YAAY,EAAE;AAAA,EACnE;AACF;AAEO,SAAS,qBAAqB,GAKlB;AACjB,SAAO;AAAA,IACL,OAAO,EAAE,MAAM,EAAE,MAAM,QAAQ,EAAE,OAAO;AAAA,IACxC,KAAK,EAAE,MAAM,EAAE,WAAW,GAAG,QAAQ,EAAE,UAAU;AAAA,EACnD;AACF;AAQO,SAAS,2BACd,QACA,QACA,QACgB;AAChB,QAAM,aAAa,EAAE,MAAM,GAAG,QAAQ,EAAE;AAExC,MAAI,CAAC,UAAU,OAAO,WAAW,GAAG;AAClC,WAAO,EAAE,OAAO,EAAE,GAAG,WAAW,GAAG,KAAK,EAAE,GAAG,WAAW,EAAE;AAAA,EAC5D;AAEA,QAAM,aAAa;AACnB,QAAM,WAAW,SAAS;AAE1B,MAAI,OAAO;AACX,MAAI,SAAS;AAEb,MAAI,QAAiD;AAErD,WAAS,IAAI,GAAG,IAAI,UAAU,KAAK;AACjC,QAAI,MAAM,YAAY;AACpB,cAAQ,EAAE,MAAM,OAAO;AAAA,IACzB;AAEA,QAAI,OAAO,CAAC,MAAM,MAAM;AACtB;AACA,eAAS;AAAA,IACX,OAAO;AACL;AAAA,IACF;AAAA,EACF;AAEA,oBAAU,EAAE,MAAM,OAAO;AACzB,QAAM,MAAM,EAAE,MAAM,OAAO;AAE3B,SAAO,EAAE,OAAO,IAAI;AACtB;","names":[]}